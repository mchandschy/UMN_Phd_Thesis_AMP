function [mse_vec, u, t, est] = sparse_rad_3(N, p, rho, bet, lambda, num_its, index, all_indices)

%inputs:
    % N: vector length
    % p: tensor size
    % rho: sparsity parameter rho. rho = 1 gives Rademacher prior
    % bet: SNR
    % lambda: step size parameter. lambda = 0 gives AMP with no damping
    % num_its: maximum number of iterations
    % index: List of indices of all observed tensor entries.
        % Generated by index = nchoosek(1:N, p);
    % all_indices: Sparse matrix containing 1 in entry (i,j) if j appears
        % in the ith row of index
        % Generated by
        %all_indices = sparse(size(index,1),N);
            %for i = 1:N
            %all_indices(:,i) = any(index == i, 2);
            %end
            %est = zeros(N, num_its);

%Outputs:
    % mse_vec: Vector containing the MSE for each iteration
    % u: ground truth
    % t: Number of iterations performed
    % est: Matrix whose columns contain estimates at each iteration

est = zeros(N, num_its);
mse_vec = zeros(num_its,1);

u_1 = binornd(1, rho, N, 1); %random vector, 0 with probability 1-rho
u_2 = (2*binornd(1, 0.5, N, 1)-1)*1/sqrt(rho); %randomly +/- wp 1/2
u = u_1.*u_2; %Create ground truth vector u
Y_0 = prod(u(index),2); %Ground truth signal tensor
Y = Y_0/sqrt(N^(p-1));

W = normrnd(0,1/bet,size(index,1),1); %Gaussian noise

T = Y + W; %Spiked tensor

b = randn(N,1); 
a = randn(1,1);
%x_tt = randn(N,1); %Uninformative Initialization
x_tt = u + normrnd(0, .01, N,1); %Informative Initialization
x_t = lambda*x_tt + (1-lambda)*arrayfun(@(z) f_in(a,z,rho), b);
sig_t = arrayfun(@(z) db_f_in(a,z,rho), b);
t = 1;
mse = 2;

while (t <= num_its && round(mse,8) > 0 && est ~=0)
    %Stop when number of iterations reached, MSE = 0, or the estimator 
    %converges to the zero (high-error) vector
    for i = 1:N
        ind_i = find(full(all_indices(:,i)));
        x_tmp = x_t;
        x_tmp(i) = 1;
        b(i) = (bet^2/sqrt(N^(p-1)))*T(ind_i)'*prod(x_tmp(index(ind_i,:)),2) - ((p-1)*bet^2/N^(p-1))*x_tt(i)*sum(sig_t)*(x_t'*x_tt)^(p-2); 
    end
    
    a = (bet^2/N^(p-1))*(x_t'*x_t)^(p-1);
    x_tt = x_t;
    x_t = lambda*x_t + (1-lambda)*arrayfun(@(z) f_in(a,z,rho), b);
    sig_t = (lambda)*x_t + (1-lambda)*arrayfun(@(z) db_f_in(a,z,rho), b);
    est(:, t) = x_t';
    mse = min(mean((Y_0-prod(x_t(index),2)).^2), mean((-Y_0-prod(x_t(index),2)).^2));
    mse_vec(t) = mse;
    t = t+1;
end
t = t-1;

end